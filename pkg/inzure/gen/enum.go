package main

import (
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"
	"unicode"
)

var (
	templateParams = templateArgs{
		PkgName: "inzure",
	}

	enumPrefix    string
	noUnknown     = false
	noStrings     = false
	noIsFunctions = false
	values        string
	azureValues   string
)

func main() {

	flag.StringVar(&enumPrefix, "prefix", enumPrefix, "Required prefix for the enum")

	flag.StringVar(&templateParams.TypeName, "type-name", templateParams.TypeName, "Type name, otherwise defaults to -prefix value")
	flag.BoolVar(&noUnknown, "no-unknown", noUnknown, "Don't add an Unknown variant as the default value")
	flag.StringVar(&values, "values", values, "Comma separated list of values to generate")
	flag.BoolVar(&noStrings, "no-string", noStrings, "Don't generate String function as well")
	flag.BoolVar(&noIsFunctions, "no-is-functions", noIsFunctions, "Don't generate Is{Name} functions")
	flag.StringVar(&templateParams.PkgName, "pkg", templateParams.PkgName, "Package name")

	flag.StringVar(&templateParams.AzureImport, "azure-import", templateParams.AzureImport, "Azure import path")
	flag.StringVar(&templateParams.AzureType, "azure-type", templateParams.AzureType, "Azure type, not including package prefix")
	flag.StringVar(&azureValues, "azure-values", azureValues, "Corresponding Azure values not including package prefix, if set this generate a FromAzure function")

	flag.Parse()

	requiredString(enumPrefix, "-prefix is required")
	requiredString(values, "-values is required")

	hasAzure := azureValues != ""
	var asAzure []string

	if hasAzure {
		requiredString(templateParams.AzureType, "need to set -azure-type")
		requiredString(templateParams.AzureImport, "need to set -azure-import")
		for _, s := range strings.Split(azureValues, ",") {
			asAzure = append(asAzure, s)
		}
	}

	intValue := 0

	if !noUnknown {
		templateParams.UnknownValue = enumPrefix + "Unknown"
		intValue += 1
	}
	for i, val := range strings.Split(values, ",") {
		ev := enumValue{Value: intValue, Name: enumPrefix + val, ShortName: val}
		if hasAzure {
			ev.AzureValue = asAzure[i]
		}
		templateParams.Values = append(templateParams.Values, ev)
		intValue += 1
	}

	if templateParams.TypeName == "" {
		templateParams.TypeName = enumPrefix
	}

	templateParams.GenStrings = !noStrings
	templateParams.GenIsFunctions = !noIsFunctions
	templateParams.HasUnknown = !noUnknown

	outFile, err := os.OpenFile(typeToFileName(templateParams.TypeName), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0664)
	if err != nil {
		fmt.Fprintln(os.Stderr, "failed to open output file:", outFile)
		os.Exit(1)
	}
	defer outFile.Close()

	templ := template.Must(template.New("enum").Parse(enumTemplate))

	if err := templ.Execute(outFile, &templateParams); err != nil {
		fmt.Fprintln(os.Stderr, "failed to execute template:", err)
		os.Exit(1)
	}

}

func typeToFileName(typeName string) string {
	var s strings.Builder
	s.WriteString("enum_")

	prevLower := false

	for _, r := range typeName {
		if unicode.IsUpper(r) {
			if prevLower {
				s.WriteRune('_')
			}
			s.WriteRune(unicode.ToLower(r))
			prevLower = false
		} else {
			prevLower = true
			s.WriteRune(r)
		}
	}
	s.WriteString(".go")
	return s.String()
}

func requiredString(value string, msg string) {
	if value == "" {
		fmt.Fprintln(os.Stderr, msg)
		os.Exit(1)
	}
}

type enumValue struct {
	ShortName  string
	Name       string
	Value      int
	AzureValue string
}

type templateArgs struct {
	PkgName  string
	TypeName string

	AzureType   string
	AzureImport string

	UnknownValue string

	HasUnknown     bool
	GenStrings     bool
	GenIsFunctions bool

	Values []enumValue
}

func (ta *templateArgs) HasAzureValues() bool {
	for _, v := range ta.Values {
		if v.AzureValue == "" {
			return false
		}
	}
	return true
}

const enumTemplate = `// Code generated by go generate; DO NOT EDIT.

package {{ .PkgName }}

{{ if .AzureImport }}
import (
	{{- if .GenStrings }}
	"fmt"
	{{- end }}
	azpkg "{{ .AzureImport }}"
)
{{ else if .GenStrings }}
import "fmt"
{{ end }}

{{ $hasUnknown := .HasUnknown -}}
{{ $unknownValue := .UnknownValue -}}
{{ $typeName := .TypeName -}}

type {{ $typeName }} int

const (
{{- if .HasUnknown }}
	{{ .UnknownValue }} {{ $typeName }} = 0
{{- end -}}
{{- range .Values }}
    {{ .Name }} {{ $typeName }} = {{ .Value -}}
{{- end }}
)

{{ if .HasAzureValues }}
{{ if $hasUnknown }}
func (it *{{ $typeName }}) FromAzure(az *azpkg.{{ .AzureType }}) {
	if (az == nil) {
		*it = {{ .UnknownValue }}
		return
	}
	switch(*az) {
	{{- range .Values }}
	case azpkg.{{ .AzureValue }}:
		*it = {{ .Name -}}
	{{ end }}
	default:
		*it = {{ .UnknownValue }}
	}
}
{{ else }}
func (it *{{ $typeName }}) FromAzure(az *azpkg.{{ .AzureType }}) {
	if (az == nil) {
		*it = {{ $typeName }}(0)
		return
	}
	switch(*az) {
	{{- range .Values }}
	case azpkg.{{ .AzureValue }}:
		*it = {{ .Name -}}
	{{ end }}
	default:
		*it = {{ $typeName }}(0)
	}
}
{{ end -}}
{{ end -}}

{{ if .GenIsFunctions -}}
{{ if $hasUnknown -}}
func (it {{ $typeName }}) IsUnknown() bool {
	return it == {{ $unknownValue }}
}

func (it {{ $typeName }}) IsKnown() bool {
	return it != {{ $unknownValue }}
}

{{ end -}}
{{ range .Values -}}
{{ if $hasUnknown -}}
func (it {{ $typeName }}) Is{{ .ShortName }}() UnknownBool {
	if it == {{ $unknownValue }} {
		return BoolUnknown
	}
	return UnknownFromBool(it == {{ .Name }})
}

{{ else }}
func (it {{ $typeName }}) Is{{ .ShortName }}() bool {
	return it == {{ .Name }}
}

{{ end -}}
{{ end -}}
{{ end -}}
{{ if .GenStrings }}
func (it {{ $typeName }}) String() string {
	switch (it) {
	{{- range .Values }}
	case {{ .Name }}:
		return "{{ .ShortName }}"
	{{- end }}
	default:
		return fmt.Sprintf("{{ $typeName }}(%d)", it)
	}
}
{{ end }}
`
